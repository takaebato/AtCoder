#include <bits/stdc++.h>
using namespace std;
using ll = long long;

#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define repg(i, j, n) for (int i = (int)j; i < (int)(n); i++)
#define repi(i, n) for (int i = (int)(n)-1; i >= 0; i--)
#define repig(i, j, n) for (int i = (int)(n)-1; i >= (int)j; i--)

int main() {
    /*
      DPとは何なのかを考えたい。
      全探索としてまず考える。
      N<=3*10^5, Ai<=10^9
      BF: エサのあげ方自体は終わりがなく無限通りになるため、最悪でもN種類を1回ずつという制約で考える。
          愚直全探索ならi番目の行動をとるとらないの2値の組み合わせで、2^N通り。判定で線形に見てNだから、合計でO(N2^N)だろうか。
      普通に考えてメモ化か。
      全ての経路を見て全ての取り得る値を調べるなら、やはり2^N通りの探索が必要になる。しかし、今回欲しいのは最小値のみ。
      greedyの少し制約増えた版みたいな。全ての経路を探索せずとも、各ステップで最適解を決定していけるみたいな。
      仮に問いが、「値が1000となる行動の仕方を出力せよ」になると、これは全探索が必要になると思う。各ステップで最小値なら決定できるが、合計値が1000となるかは決定できない。
      状態圧縮といえばまあそうなんだけど。
      DPもグラフで表せる。最短経路問題と同じと言っていい。特徴としては、少なめの状態数のノード同士が長く連なっている感じか。

      で、今回はグラフの終端が最初のノードと繋がって円環っぽくなっているから、その始点と終点あたりの状態遷移の条件を考える必要がある感じか。
      普通は左から右に状態遷移を考えるだけで良いケースが多いと思う。
    */
    int N;
    cin >> N;
    vector<int> a(N);
    rep(i, N) cin >> a[i];
    vector<vector<ll>> dp(N, vector<ll>(2));
    ll ans;
    // 終端選択する場合
    dp[0][0] = 0;
    dp[0][1] = a[0];
    repg(i, 1, N) {
        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a[i];
        dp[i][0] = dp[i - 1][1];
    }
    ans = dp[N - 1][1];
    // 終端選択しない場合
    dp.assign(N, vector<ll>(2, 1e18));
    dp[0][0] = a[0] + 1;
    dp[0][1] = a[0];
    repg(i, 1, N) {
        dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + a[i];
        dp[i][0] = dp[i - 1][1];
    }
    ans = min(ans, dp[N - 1][0]);
    cout << ans << endl;
}
